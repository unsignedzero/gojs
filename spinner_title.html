<!DOCTYPE HTML>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html"; charset="utf-8" />
    <meta name="description" content="Go Board Test Page" />
    <meta name="robots" content="noodp" >
    <meta name="ROBOTS" content="NOINDEX">

    <link rel="shortcut icon" href="ZCS1.ico" />
    <title>Go DEMO Page</title>

    <link rel="stylesheet" type="text/css" href="CSS/reset.css" />

    <script type="application/javascript" src="LIB/kinetic-v4.3.0.min.js"></script>
  </head>
  <body>
    <div id="container"></div>
    <script>

      function drawCircleTitle(localLayer, x , y, radius){
        var defaultSpinAnim;
        var yinYangStartAnim,yinYangEndAnim;
        var to_end;
        var mouse_on;

        to_end = false;
        mouse_on = false;

         x += radius;
         y += radius;

        var bendValue = 240;

        var arc_end = Math.sin(Math.PI/4);
        var arc_mid = Math.tan(Math.PI/8);

        function drawYinYangShape(x, y, radius){

          function drawOutline(context){
            //Reference
            //http://board.flashkit.com/board/showthread.php?369672-Draw-a-circle-with-quadratic-bezier-curves
            context.beginPath();
            context.moveTo(x+(radius<<1), y+radius);
            context.quadraticCurveTo(
              radius+x+radius,-arc_mid*radius+y+radius,
              arc_end*radius+x+radius,-arc_end*radius+y+radius);
            context.quadraticCurveTo(
              arc_mid*radius+x+radius,        -radius+y+radius,
                             x+radius,        -radius+y+radius);
            context.quadraticCurveTo(
             -arc_mid*radius+x+radius,        -radius+y+radius,
             -arc_end*radius+x+radius,-arc_end*radius+y+radius);
            context.quadraticCurveTo(
                     -radius+x+radius,-arc_mid*radius+y+radius,
                     -radius+x+radius,                y+radius);
            context.bezierCurveTo(
                             (radius>>1)+x,radius+y-bendValue,
               ((radius   )+(radius>>1))+x,radius+y+bendValue,
                             (radius<<1)+x,radius+y);
            context.closePath();
          }

          return new Kinetic.Shape({
          x: x,
          y: y,
          offset: [x+radius,y+radius],
          fill: 'black',

          drawFunc: function(canvas) {
            drawOutline( canvas.getContext() );
            canvas.fillStroke(this);
          },

          drawHitFunc: function(canvas) {
            drawOutline( canvas.getContext() );
            canvas.fillStroke(this);
          },
          });

        }

        var circle_back = drawYinYangShape(x, y, radius);
        var circle      = drawYinYangShape(x, y, radius);

        yinYangStartAnim = (new Kinetic.Animation(function(frame){
            var angleDiff = frame.timeDiff * (Math.PI/2) / 1000;
            circle_back.rotate(angleDiff);
            if ( frame.time >= 2000 ){
              frame.time = 0;
              circle_back.setRotation(circle.getRotation()+Math.PI);
              this.stop();
              //CODE for full circle here

              //outline.setFill('black');
              if ( !mouse_on ){
                to_end  = false;
                //outline.setFill('white');
                yinYangEndAnim.start();
              }
              else
                to_end = true;
            }
          },localLayer));

       yinYangEndAnim = (new Kinetic.Animation(function(frame){
            var angleDiff = frame.timeDiff * (Math.PI/2) / 1000;
            circle_back.rotate(angleDiff);
            if ( frame.time >= 2000 ){
              frame.time = 0;
              circle_back.setRotation(circle.getRotation());
              this.stop();
              to_end = false;
              }
          },localLayer));

       defaultSpinAnim = (new Kinetic.Animation(function(frame){
            var angleDiff = frame.timeDiff * (Math.PI/2) / 1000;
            circle_back.rotate(angleDiff);
            circle.rotate(angleDiff);
          },localLayer));

        defaultSpinAnim.start();
        var outline = new Kinetic.Circle({
          x: x,
          y: y,
          radius: radius, stroke: 'black', strokeWidth: 2,
        });

        outline.on('mouseout touchstart', function(){
          circle.setFill('black');
          circle_back.setFill('black');
          localLayer.draw();

          mouse_on = false;

          defaultSpinAnim.start();
          if ( yinYangStartAnim.frame.time == 0 && yinYangEndAnim.frame.time == 0 && to_end ){
            //outline.setFill('white');
            yinYangEndAnim.start();
          }
        });

        outline.on('mouseover touchmove', function(){
          circle.setFill("#222");
          circle_back.setFill("#222");
          localLayer.draw();

          mouse_on = true;
          defaultSpinAnim.stop();
        });

        outline.on('mousedown tap', function(){
          if ( yinYangStartAnim.frame.time == 0 && yinYangEndAnim.frame.time == 0 && !to_end )
            yinYangStartAnim.start();
        });

        //circle_back.setZIndex(5);
        //circle.setZIndex(7);

        localLayer.add(circle_back);
        localLayer.add(circle);

        localLayer.add(outline);

      }

      var stage = new Kinetic.Stage({
        container: 'container',
        width: 800,
        height: 800,
      });

      var MainLayer = new Kinetic.Layer();

      drawCircleTitle(MainLayer,20,20,350);

      stage.add(MainLayer);

    </script>
  </body>
</html>
